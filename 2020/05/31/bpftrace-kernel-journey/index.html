<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Kernel journey with bpftrace · dlee 的 Blog</title><meta name="description" content="Kernel journey with bpftrace - dlee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dlee-libo.github.io/atom.xml" title="dlee 的 Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Kernel journey with bpftrace</h1><div class="post-info">2020年5月31日</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天同事和我聊起 calico 的一些实现原理，他给了我一个脚本让我试玩一下如何通过 linux 下的 veth 设备使得在单独的 network namespace 可以与 host 进行通信。意外的是，在我的笔记本上整个方案没有正确地工作。由于缺乏相关的文档支持，所以我通过使用 bpftrace 配合阅读内核的源码，终于搞明白了是什么原因导致的，借此机会记录下来展示下 bpftrace 及一些相关工具的基本用法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>通过执行下面的脚本，我们将会创建一个新的 network namepsace： <code>ns0</code> ，以及一对 veth 设备 <code>v-ns0</code> 和 <code>v-ns0-peer</code>。我们将 <code>v-ns0</code> 放入 <code>ns0</code> 中，将 <code>v-ns0-peer</code> 留在 host 中，通过开启 <code>v-ns0-peer</code> 的 proxy_arp 功能我们应当能看到 <code>v-ns0-peer</code> 设备会用自己的 MAC 地址响应 <code>v-ns0</code> 设备发出的 ARP 请求。如果进一步设置相关的转发和路由规则 <code>ns0</code> 中的进程将可以顺畅地与其他机器上的容器进行通信。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">NS=ns0</span><br><span class="line">VETH=v-<span class="variable">$NS</span></span><br><span class="line"></span><br><span class="line">ip netns add <span class="variable">$NS</span></span><br><span class="line"></span><br><span class="line">ip link add <span class="variable">$VETH</span> <span class="built_in">type</span> veth peer name <span class="variable">$VETH</span>-peer</span><br><span class="line"></span><br><span class="line">ip link <span class="built_in">set</span> <span class="variable">$VETH</span>-peer up</span><br><span class="line">ip link <span class="built_in">set</span> <span class="variable">$VETH</span> netns <span class="variable">$NS</span></span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$NS</span> ip link <span class="built_in">set</span> <span class="variable">$VETH</span> up</span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$NS</span> ip addr add 10.6.0.1/32 dev <span class="variable">$VETH</span></span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$NS</span> ip route add 169.254.0.1 dev <span class="variable">$VETH</span> scope link</span><br><span class="line">ip netns <span class="built_in">exec</span> <span class="variable">$NS</span> ip route add default via 169.254.0.1 dev <span class="variable">$VETH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/<span class="variable">$VETH</span>-peer/proxy_arp</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/<span class="variable">$VETH</span>-peer/rp_filter</span><br></pre></td></tr></table></figure>
<p>我面临的主要问题是在我的笔记本上执行完上面的脚本后， <code>v-ns0-peer</code> 设备的 proxy_arp 功能并没有生效，通过使用 wireshark 在 <code>v-ns0-peer</code> 上抓包同时执行 <code>ip netns exec ns0 ping 192.168.1.1</code> ，可以明显看到只有对于 <code>ns0</code> 中的默认网关 169.254.0.1 的 ARP 请求却没有任何的 ARP 应答。<br><img src="/images/no-arp-reply.png" alt="no arp reply"></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>设备 <code>v-ns0-peer</code> 的 proxy_arp 功能没有正确工作，我一开始的推测是需要开启某些设置，可能是安全策略相关的。所以一开始在 google 上找了一圈资料，但是没有发现什么特别有帮助的，于是考虑跟踪下内核的代码，看看是什么条件没有符合。直接阅读内核代码的方式来分析难度比较大，因此我选择一边阅读一边使用 trace 工具快速确定内核的执行路径，这里我选择使用的工具是 <a href="https://github.com/iovisor/bpftrace" target="_blank" rel="noopener">bpftrace</a> 。</p>
<h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p>我的笔记本是 ubuntu 20.04 的操作系统，其他操作系统下工具的安装和准备应该是类似的。</p>
<ol>
<li>获取当前内核的源代码。执行 <code>apt-get source linux-image-unsigned-$(uname -r)</code> 即可。</li>
<li>获取当前内核的 debug info 。添加源 ddebs.ubuntu.com 后执行 <code>apt-get install linux-image-$(uname -r)-dbgsym</code> 即可。</li>
<li>安装 bpftrace 以及 <a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">bcc</a> 。执行 <code>apt-get install bpftrace bpfcc-tools linux-headers-$(uname -r)</code> 即可。</li>
</ol>
<h3 id="定位内核代码"><a href="#定位内核代码" class="headerlink" title="定位内核代码"></a>定位内核代码</h3><p>我们的目标是找出 proxy_arp 功能为什么不工作，处理 ARP 请求的代码在 net/ipv4/arp.c 中的 <code>arp_process</code> 函数中。通过大致阅读该函数，我们可以迅速发现与 proxy_arp 相关的代码段应该如下 813 行附近。<br><img src="/images/code-813.png" alt="code-813"></p>
<h3 id="trace-内核"><a href="#trace-内核" class="headerlink" title="trace 内核"></a>trace 内核</h3><p>我们的 ARP 请求在设备 <code>v-ns0-peer</code> 上被收到以后内核执行到 813 行，检查 arp-&gt;ar_op 肯定是 ARPOP_REQUEST ，所以我们第一需要确定函数 <code>ip_route_input_noref</code> 的返回值。我们使用 bpftrace 来完成这项工作，通过执行 <code>bpftrace -e &#39;kretprobe:ip_route_input_noref { printf(&quot;pid %d. ret: %d\n&quot;, pid, retval); }&#39;</code> 我们可以得到 <code>ip_route_input_noref</code> 每次调用的返回值。</p>
<p>开始 trace 以后，我们还没有在 <code>ns0</code> 中执行任何操作的情况下，已经能看到一些输出了：<br><img src="/images/trace1.png" alt="trace1"><br>这个显然是机器上处理其他的 ARP 请求的时候执行的，为了排除这些干扰，我将笔记本的网络断开了，再重新开始 trace ，并执行 <code>ip netns exec ns0 ping 192.168.1.1</code> 来触发 ARP 请求。<br><img src="/images/trace2.png" alt="trace2"><br>可以看到有很多输出，有的 PID 是 ping ，有的 PID 是 0 ，所有的返回值都是 0。所以我们可以肯定代码肯定进入了816行，接下来是两个分支，819行和836行。因为函数 <code>skb_rtable</code> 被内联了，我们无法使用 bpftrace 去 trace 该函数。为了确认代码的执行路径，我们可以利用 bpftrace 的 kprobe 支持 function offset 这个特点来打点。</p>
<h4 id="反汇编内核"><a href="#反汇编内核" class="headerlink" title="反汇编内核"></a>反汇编内核</h4><p>为了知道819和837两个分支的代码相对于函数 <code>arp_process</code> 的偏移，我们使用 gdb 反汇编 <code>gdb -q /usr/lib/debug/boot/vmlinux-$(uname -r) --ex &#39;disassemble arp_process&#39;</code> ，然后迅速滚动到有函数 <code>ip_route_input_noref</code> 的调用的附近：<br><img src="/images/disasm.png" alt="disassemble"><br>从图中可以看到，函数 <code>ip_route_input_noref</code> 的调用在 +1173 的位置，接下来 +1191 判断其返回值是否为0，不为0就跳转到 arp_process+289 的位置，我们可以使用 addr2line 来确认下对应的是代码中的什么位置。执行 <code>addr2line -e /usr/lib/debug/boot/vmlinux-$(uname-r) 0xffffffff819ed861</code> 得到结果 linux-5.4.0/include/net/neighbour.h:516 。阅读代码发现是函数 <code>__neigh_lookup</code> 的实现，该函数其实是在 865 行调用的，被内联了。</p>
<p>因为我们上面 trace 知道 <code>ip_route_input_noref</code> 返回是0，所以代码执行应该是进入了816行，也就是顺着 +1197 继续执行。+1197 从内存读取一个值将低位抹掉作为地址去加载一个值，通过读代码我们知道是函数 <code>skb_rtable</code> 的内容，接着+1210的判断其实就是我们的819行的判断，读代码可以知道 <code>RTN_LOCAL</code> 的值是 2 ，<code>RTN_UNICAST</code> 的值是 1 。为了确定代码是否进入了820行，我们可以在+1219埋点，可惜的是我的笔记本上安装的 bpftrace 在编译的时候没有开启 <code>ALLOW_UNSAFE_PROBE</code> 所以当我在笔记本上执行 <code>bpftrace -e &#39;kprobe:arp_process+1219 { printf(&quot;executed\n&quot;); } &#39;</code> 的时候报错：<br><img src="/images/unsafe.png" alt="unsafe-error"></p>
<h4 id="手工使用-bcc"><a href="#手工使用-bcc" class="headerlink" title="手工使用 bcc"></a>手工使用 bcc</h4><p>bpftrace 不支持，我们可以使用 bcc 直接写程序来 trace 内核，代码非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</span><br><span class="line"></span><br><span class="line"><span class="comment"># load BPF program</span></span><br><span class="line">bpf_text = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int print_called(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">    bpf_trace_printk("executed!\\n");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">b = BPF(text=bpf_text)</span><br><span class="line">b.attach_kprobe(event=<span class="string">'arp_process'</span>, event_off=<span class="number">1219</span>, fn_name=<span class="string">'print_called'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># header</span></span><br><span class="line">print(<span class="string">'%-9s %-6s %s'</span> % (<span class="string">'TIME'</span>, <span class="string">'PID'</span>, <span class="string">'MSG'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># format output</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (task, pid, cpu, flags, ts, msg) = b.trace_fields()</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">'%-9s %-6d %s'</span> % (strftime(<span class="string">'%H:%M:%S'</span>), pid, msg))</span><br></pre></td></tr></table></figure>
<p>运行起来我们的 bcc 程序，执行 ping ，然后我们发现，+1219 是有执行到的，那么说明 <code>addr_type</code> 的值不是 <code>RTN_LOCAL</code> 。所以代码将会执行到836行的判断 <code>IN_DEV_FORWARD(in_dev)</code> ，直接看汇编代码，我们很容易看出关键是看+1229的 <code>je</code> 指令，如果发生跳转就说明没有进入837行。所以我们继续 trace +1235 即可知道，执行 ping ，我们发现 +1235 没有执行到！说明 <code>IN_DEV_FORWARD(in_dev)</code> 的判断没成功，我们进入代码库搜索发现这是一个宏，主要干的事是检查设备的 forwarding 选项是否开启。我们执行 <code>cat /proc/sys/net/ipv4/conf/v-ns0-peer/forwarding</code> 可以看到结果是0，所以我们将其修改为1后继续 trace 。现在代码顺利执行到了 +1235 ，但是抓包依然没有看到 ARP 应答。</p>
<p>我们继续看汇编，+1235 和 +1238 的判断对应代码中837行的第一个条件，测试 <code>addr_type</code> 是否是 <code>RTN_UNICAST</code> ，我们继续 trace +1244 来验证下这个条件判断是否成功。执行 ping ，我们发现这个判断失败了，所以代码执行跳到了后面，于是 proxy_arp 没有正确工作。</p>
<p>稍微阅读下代码，我们可以知道 <code>addr_type</code> 是使用我们 ARP 请求里面的目的 IP 地址查路由表后得到的讯息，这里的逻辑只是要确保我们的 IP 地址是单播地址。而我们查讯的地址 169.254.0.1 是 link-local 地址，肯定是单播地址，因此这个行为就比较奇怪了。进一步思考，结合 wikipedia 中对 proxy_arp 的一段描述：</p>
<blockquote>
<p>The proxy is aware of the location of the traffic’s destination, and offers its own MAC address as the (ostensibly final) destination.</p>
</blockquote>
<p>我猜测是因为断网状态下我的笔记本不知道如何到达 169.254.0.1 ，执行 <code>ip route get 169.254.0.1</code> 报错：RTNETLINK answers: Network is unreachable 。打开笔记本网络继续测试，首先 <code>ip route get 169.254.0.1</code> 正确返回了，然后我们退回去最开始去 trace <code>ip_route_input_noref</code> ，为了让干扰尽量少，我关闭了笔记本上大部分程序。开启 trace 后执行 ping 结果发现 <code>ip_route_input_noref</code> 居然返回了非0值：-18 。</p>
<h4 id="深入-ip-route-input-noref"><a href="#深入-ip-route-input-noref" class="headerlink" title="深入 ip_route_input_noref"></a>深入 <code>ip_route_input_noref</code></h4><p>阅读内核代码，<code>ip_route_input_noref</code> 的实现在 net/ipv4/route.c 中，一个简化的调用链路是 <code>ip_route_input_noref</code> -&gt; <code>ip_route_input_rcu</code> -&gt; <code>ip_route_input_slow</code> 。其中函数 <code>ip_route_input_slow</code> 比较复杂，而我们的目的只是简单找到返回 -18 的原因，因此我们可以跟踪产生返回值的地方，除开大部分常值不符合我们的期望外，第一个可能产生 -18 的地方是对于函数 <code>fib_validate_source</code> 的调用。执行命令 <code>bpftrace -e &#39;kretprobe:fib_validate_source { printf(&quot;pid %d. ret: %d\n&quot;, pid, retval); }&#39;</code> 并开始 ping ，我们非常幸运，果然这个函数返回了 -18 ！</p>
<h4 id="追随-fib-validate-source"><a href="#追随-fib-validate-source" class="headerlink" title="追随 fib_validate_source"></a>追随 <code>fib_validate_source</code></h4><p>函数 <code>fib_validate_source</code> 的实现在 net/ipv4/fib_frontend.c 里面，代码很短，可能产生 -18 的返回值的地方是函数 <code>__fib_validate_source</code> ，进入函数 <code>__fib_validate_source</code> 查看，很显眼看到末尾的 <code>return -EXDEV</code> ，简单用个 C 程序验证就发现 errno EXDEV 正好是 18！阅读代码发现导致返回 EXDEV 的原因是参数 rpf 非0，而该参数是上层函数 <code>fib_validate_source</code> 传进来的，值是这样得到的：<code>int r = secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);</code> 。所以说明是 <code>secpath_exists(skb)</code> 返回了0，然后 <code>IN_DEV_RPFILTER</code> 返回了非0值。但是我们一开始的脚本里面明明是有这样一句的 <code>echo 0 &gt; /proc/sys/net/ipv4/conf/$VETH-peer/rp_filter</code> ，所以这里就比较奇怪了。</p>
<p>到这里我们知道了方向但是依然不知道最终的原因是什么，我们继续看看 <code>IN_DEV_RPFILTER</code> 的实现有什么奇怪的地方。在 include/linux/inetdevice.h 中我们找到了这个宏的定义为： <code>#define IN_DEV_RPFILTER(in_dev)        IN_DEV_MAXCONF((in_dev), RP_FILTER)</code> ，我们继续看 <code>IN_DEV_MAXCONF</code> 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_DEV_MAXCONF(in_dev, attr) \</span></span><br><span class="line">	(<span class="built_in">max</span>(IPV4_DEVCONF_ALL(dev_net(in_dev-&gt;dev), attr), \</span><br><span class="line">	     IN_DEV_CONF_GET((in_dev), attr)))</span><br></pre></td></tr></table></figure>
<p>啊哈！原来这个是取全局的值和设备的值中的较大者。执行 <code>cat /proc/sys/net/ipv4/conf/all/rp_filter</code> 发现该值为 2，将其修改为0后再进行测试， ARP 应答正确出现！<br><img src="/images/arp-reply.png" alt="arp reply"></p>
</div></article></div></main><footer><div class="paginator"><a href="/2025/06/13/Open-Source-Hardware-and-the-Reshaping-of-the-Software-Industry-Growth-Consolidation-and-Cultural-Lag/" class="prev">上一篇</a><a href="/2019/05/13/UNIX-process-UID-model/" class="next">下一篇</a></div><div class="copyright"><p>© 2018 - 2025 <a href="http://dlee-libo.github.io">dlee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><!--script(async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous")--></body></html>